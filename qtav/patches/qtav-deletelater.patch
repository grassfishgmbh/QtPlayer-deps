diff --git a/src/AVPlayer.cpp b/src/AVPlayer.cpp
index f6021a5..2e71f49 100644
--- a/src/AVPlayer.cpp
+++ b/src/AVPlayer.cpp
@@ -693,22 +693,19 @@ void AVPlayer::loadInternal()
 
 void AVPlayer::unload()
 {
-    if (!isLoaded())
-        return;
     QMutexLocker lock(&d->load_mutex);
     Q_UNUSED(lock);
+
+    if (!isLoaded())
+        return;
     d->loaded = false;
     d->demuxer.setInterruptStatus(-1);
 
     if (d->adec) { // FIXME: crash if audio external=>internal then replay
         d->adec->setCodecContext(0);
-        delete d->adec;
-        d->adec = 0;
     }
     if (d->vdec) {
         d->vdec->setCodecContext(0);
-        delete d->vdec;
-        d->vdec = 0;
     }
     d->demuxer.unload();
     Q_EMIT durationChanged(0LL); // for ui, slider is invalid. use stopped instead, and remove this signal here?
@@ -1271,7 +1268,7 @@ void AVPlayer::stopFromDemuxerThread()
         /*
          * currently preload is not supported. so always unload. Then some properties will be reset, e.g. duration()
          */
-        unload(); //TODO: invoke?
+        QMetaObject::invokeMethod(this, "unload");
     } else {
         d->repeat_current++;
         QMetaObject::invokeMethod(this, "play"); //ensure play() is called from player thread
@@ -1388,7 +1385,7 @@ void AVPlayer::stop()
             if (QThread::currentThread() == thread()) { //called by user in the same thread as player
                 stopNotifyTimer();
             } else {
-                //TODO: post event.
+                QMetaObject::invokeMethod(this, "stopNotifyTimer");
             }
         }
         // vars not set by user can be reset
diff --git a/src/AVPlayerPrivate.cpp b/src/AVPlayerPrivate.cpp
index f6cde62..24e412b 100644
--- a/src/AVPlayerPrivate.cpp
+++ b/src/AVPlayerPrivate.cpp
@@ -133,11 +133,11 @@ AVPlayer::Private::~Private() {
         ao = 0;
     }
     if (adec) {
-        delete adec;
+        adec->deleteLater();
         adec = 0;
     }
     if (vdec) {
-        delete vdec;
+        vdec->deleteLater();
         vdec = 0;
     }
     if (vos) {
@@ -349,7 +349,7 @@ bool AVPlayer::Private::setupAudioThread(AVPlayer *player)
     // TODO: no delete, just reset avctx and reopen
     if (adec) {
         adec->disconnect();
-        delete adec;
+        adec->deleteLater();
         adec = 0;
     }
     adec = AudioDecoder::create();
@@ -522,7 +522,7 @@ bool AVPlayer::Private::tryApplyDecoderPriority(AVPlayer *player)
     vthread->setDecoder(vd);
     // MUST delete decoder after video thread set the decoder to ensure the deleted vdec will not be used in vthread!
     if (vdec)
-        delete vdec;
+        vdec->deleteLater();
     vdec = vd;
     QObject::connect(vdec, SIGNAL(error(QtAV::AVError)), player, SIGNAL(error(QtAV::AVError)));
     initVideoStatistics(demuxer.videoStream());
@@ -546,7 +546,7 @@ bool AVPlayer::Private::setupVideoThread(AVPlayer *player)
     }
     if (vdec) {
         vdec->disconnect();
-        delete vdec;
+        vdec->deleteLater();
         vdec = 0;
     }
     foreach(VideoDecoderId vid, vc_ids) {
diff --git a/src/QtAV/AVPlayer.h b/src/QtAV/AVPlayer.h
index 0dea54c..6f12767 100644
--- a/src/QtAV/AVPlayer.h
+++ b/src/QtAV/AVPlayer.h
@@ -595,7 +595,7 @@ private:
      * \brief unload
      * If the media is loading or loaded but not playing, unload it. Internall use only.
      */
-    void unload(); //TODO: private. call in stop() if not load() by user? or always unload() in stop()?
+    Q_INVOKABLE void unload(); //TODO: private. call in stop() if not load() by user? or always unload() in stop()?
     qint64 normalizedPosition(qint64 pos);
     class Private;
     QScopedPointer<Private> d;
diff --git a/src/codec/AVDecoder.cpp b/src/codec/AVDecoder.cpp
index 4c3fce6..be55bfe 100644
--- a/src/codec/AVDecoder.cpp
+++ b/src/codec/AVDecoder.cpp
@@ -76,11 +76,16 @@ bool AVDecoder::open()
     const QString hwa = property("hwaccel").toString();
     AVCodec* codec = get_codec(codecName(), hwa, d.codec_ctx->codec_id);
     if (!codec) { // TODO: can be null for none-ffmpeg based decoders
-        QString es(tr("No codec could be found for '%1'"));
+        QString es = QStringLiteral("No codec could be found for '%1'");
         if (d.codec_name.isEmpty()) {
-            es = es.arg(QLatin1String(avcodec_get_name(d.codec_ctx->codec_id)));
-            if (!hwa.isEmpty())
-                es.append('_').append(hwa);
+            const char* tmpCodecName = avcodec_get_name(d.codec_ctx->codec_id);
+            if (!tmpCodecName) {
+                es = es.arg(QStringLiteral("unknown"));
+            } else {
+                es = es.arg(QString(tmpCodecName));
+                if (!hwa.isEmpty())
+                    es.append('_').append(hwa);
+            }
         } else {
             es = es.arg(d.codec_name);
         }
@@ -122,10 +127,10 @@ bool AVDecoder::open()
 
 bool AVDecoder::close()
 {
-    if (!isOpen()) {
+    DPTR_D(AVDecoder);
+    if (Q_UNLIKELY(!isOpen())) {
         return true;
     }
-    DPTR_D(AVDecoder);
     d.is_open = false;
     // hwa extra finalize can be here
     flush();
diff --git a/src/codec/audio/AudioDecoder.cpp b/src/codec/audio/AudioDecoder.cpp
index f847657..3b741a9 100644
--- a/src/codec/audio/AudioDecoder.cpp
+++ b/src/codec/audio/AudioDecoder.cpp
@@ -41,15 +41,21 @@ void AudioDecoder::registerAll() {
 QStringList AudioDecoder::supportedCodecs()
 {
     static QStringList codecs;
-    if (!codecs.isEmpty())
-        return codecs;
-    avcodec_register_all();
-    AVCodec* c = NULL;
-    while ((c=av_codec_next(c))) {
-        if (!av_codec_is_decoder(c) || c->type != AVMEDIA_TYPE_AUDIO)
-            continue;
-        codecs.append(QString::fromLatin1(c->name));
+
+    try {
+        if (!codecs.isEmpty())
+            return codecs;
+        avcodec_register_all();
+        AVCodec* c = NULL;
+        while ((c=av_codec_next(c))) {
+            if (!av_codec_is_decoder(c) || c->type != AVMEDIA_TYPE_AUDIO)
+                continue;
+            codecs.append(QString::fromLatin1(c->name));
+        }
+    } catch (std::exception &x) {
+        qWarning() << "caught exception" << x.what();
     }
+
     return codecs;
 }
 
diff --git a/src/codec/audio/AudioEncoder.cpp b/src/codec/audio/AudioEncoder.cpp
index e9920c2..3d7a306 100644
--- a/src/codec/audio/AudioEncoder.cpp
+++ b/src/codec/audio/AudioEncoder.cpp
@@ -43,15 +43,21 @@ void AudioEncoder_RegisterAll()
 QStringList AudioEncoder::supportedCodecs()
 {
     static QStringList codecs;
-    if (!codecs.isEmpty())
-        return codecs;
-    avcodec_register_all();
-    AVCodec* c = NULL;
-    while ((c=av_codec_next(c))) {
-        if (!av_codec_is_encoder(c) || c->type != AVMEDIA_TYPE_AUDIO)
-            continue;
-        codecs.append(QString::fromLatin1(c->name));
+
+    try {
+        if (!codecs.isEmpty())
+            return codecs;
+        avcodec_register_all();
+        AVCodec* c = NULL;
+        while ((c=av_codec_next(c))) {
+            if (!av_codec_is_encoder(c) || c->type != AVMEDIA_TYPE_AUDIO)
+                continue;
+            codecs.append(QString::fromLatin1(c->name));
+        }
+    } catch (std::exception &x) {
+        qWarning() << "caught exception" << x.what();
     }
+
     return codecs;
 }
 
diff --git a/src/codec/video/VideoDecoder.cpp b/src/codec/video/VideoDecoder.cpp
index bd7c4f9..18aaa9e 100644
--- a/src/codec/video/VideoDecoder.cpp
+++ b/src/codec/video/VideoDecoder.cpp
@@ -91,15 +91,21 @@ QVector<VideoDecoderId> VideoDecoder::registered()
 QStringList VideoDecoder::supportedCodecs()
 {
     static QStringList codecs;
-    if (!codecs.isEmpty())
-        return codecs;
-    avcodec_register_all();
-    AVCodec* c = NULL;
-    while ((c=av_codec_next(c))) {
-        if (!av_codec_is_decoder(c) || c->type != AVMEDIA_TYPE_VIDEO)
-            continue;
-        codecs.append(QString::fromLatin1(c->name));
+
+    try {
+        if (!codecs.isEmpty())
+            return codecs;
+        avcodec_register_all();
+        AVCodec* c = NULL;
+        while ((c=av_codec_next(c))) {
+            if (!av_codec_is_decoder(c) || c->type != AVMEDIA_TYPE_VIDEO)
+                continue;
+            codecs.append(QString::fromLatin1(c->name));
+        }
+    } catch (std::exception &x) {
+        qWarning() << "Unhandled exception" << x.what();
     }
+
     return codecs;
 }
 
diff --git a/src/codec/video/VideoDecoderDXVA.cpp b/src/codec/video/VideoDecoderDXVA.cpp
index 64b12f3..a325982 100644
--- a/src/codec/video/VideoDecoderDXVA.cpp
+++ b/src/codec/video/VideoDecoderDXVA.cpp
@@ -314,9 +314,16 @@ QVector<GUID> VideoDecoderDXVAPrivate::getSupportedCodecs() const
     UINT input_count = 0;
     GUID *input_list = NULL;
     QVector<GUID> guids;
+
     DX_ENSURE_OK(vs->GetDecoderDeviceGuids(&input_count, &input_list), guids);
-    guids.resize(input_count);
-    memcpy(guids.data(), input_list, input_count*sizeof(GUID));
+
+    if (input_count < 1 || !input_list)
+        return guids;
+
+    for (UINT i = 0; i < input_count; ++i) {
+        guids.append(input_list[i]);
+    }
+
     CoTaskMemFree(input_list);
     return guids;
 }
diff --git a/src/codec/video/VideoEncoder.cpp b/src/codec/video/VideoEncoder.cpp
index 353085d..7c5d304 100644
--- a/src/codec/video/VideoEncoder.cpp
+++ b/src/codec/video/VideoEncoder.cpp
@@ -44,15 +44,21 @@ QStringList VideoEncoder::supportedCodecs()
 {
     // should check every registered encoders
     static QStringList codecs;
-    if (!codecs.isEmpty())
-        return codecs;
-    avcodec_register_all();
-    AVCodec* c = NULL;
-    while ((c=av_codec_next(c))) {
-        if (!av_codec_is_encoder(c) || c->type != AVMEDIA_TYPE_VIDEO)
-            continue;
-        codecs.append(QString::fromLatin1(c->name));
+
+    try {
+        if (!codecs.isEmpty())
+            return codecs;
+        avcodec_register_all();
+        AVCodec* c = NULL;
+        while ((c=av_codec_next(c))) {
+            if (!av_codec_is_encoder(c) || c->type != AVMEDIA_TYPE_VIDEO)
+                continue;
+            codecs.append(QString::fromLatin1(c->name));
+        }
+    } catch (std::exception &x) {
+        qWarning() << "caught exception" << x.what();
     }
+
     return codecs;
 }
 
diff --git a/src/vaapi/SurfaceInteropVAAPI.cpp b/src/vaapi/SurfaceInteropVAAPI.cpp
index d70a0b7..7bf898f 100644
--- a/src/vaapi/SurfaceInteropVAAPI.cpp
+++ b/src/vaapi/SurfaceInteropVAAPI.cpp
@@ -401,13 +401,13 @@ bool X11InteropResource::map(const surface_ptr& surface, GLuint tex, int w, int
     if (!ensurePixmaps(w, h)) //pixmap with frame size
         return false;
     VAWARN(vaSyncSurface(surface->vadisplay(), surface->get()));
+    XSync((::Display*)xdisplay, False);
     // FIXME: invalid surface at the first time vaPutSurface is called. If return false, vaPutSurface will always fail, why?
     VAWARN(vaPutSurface(surface->vadisplay(), surface->get(), x11->pixmap
                                 , 0, 0, w, h
                                 , 0, 0, w, h
                                 , NULL, 0, VA_FRAME_PICTURE | surface->colorSpace())
                    );
-    XSync((::Display*)xdisplay, False);
     DYGL(glBindTexture(GL_TEXTURE_2D, tex));
     x11->bindTexture();
     DYGL(glBindTexture(GL_TEXTURE_2D, 0));
